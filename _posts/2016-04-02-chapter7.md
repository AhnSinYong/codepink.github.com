## 7장 함수 표현식

### 개요
- 함수를 정의하는 방법은 **함수 선언**과 **함수 표현식** 2가지가 있다.
```javascript
function funcName() {..} // 함수 선언

var funcName = function() {..} // 함수 표현식
```

- 함수 선언으로 정의된 함수는 **함수 선언 끌어올림(hoisting)**이 발생하며, 함수 실행 코드가 선언보다 먼저 있어도 저상적으로 동작된다.
```javascript
funcName(); // 실행, 'hello js'

function funcName() { // 정의 (함수 선언)
  console.log('hello js');
}
```

- 함수 표현식으로 정의된 함수는 일반적인 함수 선언과 다르게 반드시 실행보다 선언이 먼저 되어 있어야 한다.
```javascript
funcName(); // 실행, error

var funcName = function() { // 정의 (함수 선언식)
  console.log('hello js');
}
```

- 함수 선언식은 단순 호출의 용도 외에 다양한 방법으로 사용될 수 있다.


### 7.1 재귀
- **재귀(recursive) 함수**는 함수 내부에서 자기 자신을 호출한다.
- 재귀 함수의 함수명을 변경했을 때 함수 내부에서도 호출하는 함수명을 매번 변경해야 하는 번거로움이 있다.
- ```arguments.callee()``` 메서드를 사용하여 재귀 함수의 단점을 해결할 수 있으나 strict 모드에서 에러를 발생한다.
- **이름 붙은 함수 표현식**을 사용하면 재귀 문제를 해결한다.

##### 일반적인 재귀 함수

```javascript
function totalSum(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num + totalSum(num - 1);
  }
}

totalSum(10); // 55
```

##### 함수 표현식을 사용한 재귀 함수

```javascript
var totalSum = (function f(num) {
  if (num <= 1) { 
    return 1;
  } else {
    return num + f(num - 1);
  }
});

totalSum(10); // 55 
```

### 7.2 클로저
- 이 절에서 설명하는 클로저는 **클로저 함수**에 해당한다.
- 클로저 함수는 다른 함수 스코프에 있는 변수(지역 변수, 매개변수)에 접근 가능한 함수이다.
- _클로저에 대해서는 다른 절에서 좀 더 상세하게 다룬다._

#### 7.2.1 클로저와 변수
- 스코프 체인에서 클로저가 외부 함수의 변수에 접근할 때 **마지막에 저장된 값**만 알 수 있다.
- 클로저 함수를 배열에 담아 외부 함수의 서로 다른 변수 값을 출력하려고 할 때 주로 발생하며 **클로저 비꼬기**에 해당한다.
- 함수 표현식의 한 종류인 **익명 함수**로 클로저 함수를 감싸고 호출하면 서로 다른 값을 얻을 수 있다.

##### 클로저 함수 배열에 담아 호출하기

```javascript
function getTrackNum() {
  var trackInfo = [],
      i = 0,
      len = 3;
  
  for (; i < len; i += 1) {
    trackInfo[i] = function() {
      return (i + 1) + '번';
    };
  }
  
  return trackInfo;
}

var tracks = getTrackNum();

console.log(tracks[0]()); // '4번'
console.log(tracks[1]()); // '4번'
console.log(tracks[2]()); // '4번'
```

##### 클로저 비꼬기

```javascript
function getTrackNum() {
  var trackInfo = [],
      i = 0,
      len = 3;
  
  for (; i < len; i += 1) {
    trackInfo[i] = (function(num) { // 할당과 동시에 즉시 실행된다.
      return function() {
        return (num + 1) + '번';
      }
    })(i);
  }
  
  return trackInfo;
}

var tracks = getTrackNum();

console.log(tracks[0]()); // '1번'
console.log(tracks[1]()); // '2번'
console.log(tracks[2]()); // '3번'
```

#### 7.2.2 this 객체
- ```this``` 객체는 함수가 실행 중인 컨텍스트에 묶인다.
- 클로저 함수 내부에서 ```strict``` 모드 사용 여부에 따라 ```this``` 객체가 가리키는 값이 달라진다.
- 클로저 함수를 호출할 때 일반 모드이면 ```this``` 객체는 ```window```이며, ```strict``` 모드이면 ```undefined``` 상태가 된다.
- 클로저에서 접근하는 변수가 전역 스코프가 아닌 현재 클로저 함수가 선언되어 있는 객체에 선언되어 있다면, ```this``` 객체를 지역 변수에 저장해 접근할 수 있다.

##### 일반 모드에서 this 객체의 참조 상태

```javascript
var title = 'Global Sing';

var song = {
  title: 'Sing',
  getTitle: function() {
    return function() {
      return this.title;
    }
  }
};

song.getTitle()(); // 'Global Sing'
```

##### this 객체가 클로저 함수가 선언된 객체를 참조하도록 변경

```javascript
var title = 'Global Sing';

var song = {
  title: 'Sing',
  getTitle: function() {
    var self = this;
    
    return function() {
      return self.title;
    }
  }
};

song.getTitle()(); // 'Sing'
```

#### 7.2.3 메모리 누수
- IE9 이전 버전에서는 클로저가 메모리 문제를 일으킬 수 있다.
- 클로저 함수는 활성화 객체에 대한 참조를 계속 유지하려고 하기 때문에, 1개라도 존재할 경우 메모리를 회수할 수 없기 때문에 성능 문제가 발생한다.

##### 메모리 누수가 발생하는 경우

```javascript
function bindEvent() {
  var target = document.getElementById('seletor'),
      id = target.id;
      
  target.onclick = function() { // 클로저 함수
    console.log(id);
  };
}
```

##### 메모리 누수 방지하기

```javascript
function bindEvent() {
  var target = document.getElementById('seletor'),
      id = target.id;
      
  target.onclick = function() {
    console.log(id);
  };
  
  target = null; // 클로저 함수에서 특별히 target을 참조하지 않는 경우에 사용한다.
}
```


### 7.3 블록 스코프 흉내내기
- 자바스크립트는 다른 언어와 다르게 **블록 레벨 스코프**가 없고 함수 스코프만 있다. 즉, 변수의 유효 범위가 ```{}``` 블록을 만날때마다 묶이는 것이 아니다.
- **즉시 실행 함수 표현식(immediately invoked function expression)**를 이용하면 블록 레벨 스코프를 흉내낼 수 있다.
```javascript
(function() { // IIFE
  ...
})();
```
- 이렇게 생성된 스코프를 **고유 스코프**라고 부른다.

##### 일반적인 스코프에서 변수를 재사용 할 경우

```javascript
function scopeTest() {
  var i = 0,
      len = 3;
  
  for (; i < len; i += 1) {
    console.log(i);
  }
  
  var i;
  
  console.log(i); // 3
}

scopeTest();
```

##### 함수 표현식을 사용한 스코프에서 변수를 재사용 할 경우

```javascript
function scopeTest() {
  (function() {
    var i = 0,
        len = 3;
    
    for (; i < len; i += 1) {
      console.log(i); // 0, 1, 2
    }
  })();
  
  console.log(i); // error
}

scopeTest();
```

### 7.4 고유 변수 
- 자바스크립트에서 **고유 변수**는 함수 내부에 선언된 변수이며 매개변수, 지역 변수, 내부 함수가 이에 해당된다.
- 고유 변수는 함수 실행이 끝나면 외부 스코프에서 접근할 수 없지만, 클로저를 이용하면 외부에서도 접근할 수 있다.
- 고유 변수에 접근할 수 있는 클로저 함수를 **특권(privileaged) 메서드**라고 하며 함수 표현식으로 구현된다.

```javascript
function Song(year) { // 고유 변수 1 (매개변수)
  var title = 'Sing'; // 고유 변수 2 (지역 변수)

  function privateFunc() { // 고유 변수 3 (함수)
    return title + ' released in ' + year;
  }
  
  this.publicFunc = function() { // 함수 표현식으로 정의된 특권 메서드
    return privateFunc();
  }
}

var mySong = new Song(2014);

mySong.publicFunc(); // 'Sing released in 2014'
```

#### 7.4.1 정적 고유 변수
- 특권 메서드는 **고유 스코프**를 통해서 생성할 수도 있다.
- 고유 스코프 안에서 함수 표현식을 사용해 생성자를 정의한며, 선언 시 ```var``` 키워드를 사용하지 않고 글로벌 영역에 위치시킨다.
- 인스턴스를 생성할 때마다 정적 고유 변수의 값을 덮어쓰게 된다. (독립된 값을 가질 수 없다)

```javascript
(function() {
  var title = '', // 정적 고유 변수 1
      desc = '';  // 정적 고유 변수 2
  
  Song = function(newTitle) { // 생성자 함수
    title = newTitle;
  };
  
  Song.prototype.getTitle = function() { // 특권 메서드 1
    return title;
  };
  
  Song.prototype.getDescription = function() { // 특권 메서드 2
    return desc;
  };

  Song.prototype.setDescription = function(year) { // 특권 메서드 3
    desc = title + ' released in ' + year;
  };
})();

var mySong = new Song('Sing');

console.log(mySong.getTitle()); // 'Sing'

mySong.setDescription(2014);
mySong.getDescription(); // 'Sing released in 2014'

var yourSong = new Song('Sang');

mySong.getTitle(); // 'Sang'
yourSong.getTitle(); // 'Sang'
```

#### 7.4.2 모듈 패턴
- **더글러스 크록포드(Douglas Crockford)**가 함수 표현식을 이용해 **싱글톤**을 생성하는 패턴 방식이다.
- 싱글톤은 인스턴스를 1개만 갖는 객체이다.
- 전통적인 자바스크립트에서 싱글톤 방식은 리터럴 방식으로 객체를 생성한다.
- IIFE에서 내부 함수를 객체 리터럴로 반환한다. 즉 싱글톤은 ```Object```의 인스턴스이다.

```javascript
var singletonSong = (function() {
  var title = '';
  
  function setPrivateTitle(newTitle) {
    title = newTitle;
  }
  
  function getPrivateTitle() {
    return title;
  }
  
  return {
    setTitle: function(title) {
      setPrivateTitle(title);
    },
    getTitle: function() {
      return getPrivateTitle();
    }
  };
})();

singletonSong.setTitle('Sing');
singletonSong.getTitle(); // 'Sing'
```

#### 7.4.3 모듈 확장 패턴
- 싱글톤 객체의 반환 방식을 확장한다.
- 일반 모듈 패턴과 달리 싱글톤 객체가 **특정 타입의 인스턴스**이면서 멤버(프로퍼티, 메서드)를 추가할 때 사용한다.

```javascript
function Component() {}

var app = (function() {
  var compArr = [],
      comp = new Component();
  
  comp.addComponent = function() {
    compArr.push(comp);
  };
  
  comp.getComponentCnt = function() {
    return compArr.length;
  };
  
  return comp;
})();

app.addComponent();
app.getComponentCnt(); // 1
```
