## 6장 객체 지향 프로그래밍 (2부)

### 6.2 객체 생성
- 보통 **Object 생성자 사용** 또는 **객체 리터럴** 방식으로 객체를 생성한다.

```javascript
var instance1 = new Object(); // Object 생성자 사용 방식

var instance2 = {}; // 객체 리터럴 방식
```
- 위의 방식으로 객체를 생성하면 같은 인터페이스를 가진 객체를 생성할 때 중복된 코드를 많이 써야하는 단점이 있다.
- 이를 해결하기 위해 다양한 **패턴(pattern)**의 객체 생성 방식이 등장

#### 6.2.1 팩터리 패턴
- 객체 생성 과정을 추상화 하는 방법이다.
- **추상화(abstract)**란 공통된 일을 하는 코드들을 묶어 함수로 만드는 것이다.
- **Object 생성자 사용** 방식을 이용해 객체를 생성하는 과정을 **팩터리 함수**로 만든다.
- 팩터리 함수에서 생성된 객체는 반환된다.
- 중복 코드에 대한 반복적인 작업은 줄어들지만, 생성한 객체의 타입을 알 수 없다. (모든 객체가 ```Object``` 객체로부터 생성되므로)

```javascript
function factoryOfSong(title, artist, release) {
  var o = new Object();
  
  o.title = title;
  o.artist = artist;
  
  o.getDescription = function() {
    return this.title + ' released in ' + release;
  };
  
  return o;
}

var song1 = factoryOfSong('Sing', 'Ed Sheeran', '2014'),
    song2 = factoryOfSong('Twenty-Something', 'Pet Shop Boys', '2016');
```

#### 6.2.2 생성자 패턴
- 팩터리 패턴을 확장한 방법이다.
- ```new``` 연산자를 사용해 팩터리 함수의 과정을 **생성자 함수**로 만들고, ```Object``` 객체에 할당된 멤버를 생성자 함수의 ```this``` 객체에 할당한다. (일반 함수 Vs. 생성자 함수 참조)
- 생성되는 인스턴스마다 메서드가 생성되는 단점이 있어, 메서드를 생성자 함수 밖에서 선언할 수도 있지만 이는 **전역 스코프**를 어지럽힌다.

```javascript
function Song(title, artist, release) {
  this.title = title;
  this.artist = artist;
  
  /*
  
  // this line is same below method
  this.getDescription = new Function(..);
  
  */
  this.getDescription = function() {
    return this.title + ' released in ' + release;
  };
}

var song1 = new Song('Sing', 'Ed Sheeran', '2014'),
    song2 = new Song('Twenty-Something', 'Pet Shop Boys', '2016');
```

#### 일반 함수 Vs. 생성자 함수
- 함수명 표기 방법 (규칙으로 한다)
  - 일반 함수 : 소문자 시작
  - 생성자 함수 : 대문자로 시작
- 호출 방법
  - 일반 함수 : 함수명 호출 
  - 생성자 함수 : ```new``` 연산자와 함께 사용되며 호출시 객체가 생성된다.
- 함수 내부에서 ```this``` 객체 차이
  - 일반 함수 : ```call()```, ```apply()``` 함수를 이용해 명시적으로 호출하지 않으면 ```window``` 객체에 묶인다.
  - 생성자 함수 : 현재 생성되는 객체에 묶인다.

```javascript
function Person(name, age) { // 표기법은 생성자 함수를 따르나 호출 방법에 따라 구분된다.
  this.name = name;
  this.age = age;
  
  this.printInfo = function() {
    console.log(this.name + ', ' + this.age);
  }
}

var developer = new Person('codepink', 31); // 생성자 함수로 호출

developer.getInfo(); // 'codepink, 31'

Person('codeblue', 30); // 일반 함수로 호출

window.getInfo(); // 'codeblue, 30'
```

#### 6.2.3 프로토타입 패턴
- 모든 함수는 ```prototype``` 프로퍼티를 가진다.
- ```prototype```에 멤버(프로퍼티, 메서드)를 등록하고 생성자 함수로 객체를 생성하게 되면, 생성된 객체들에게 등록된 멤버를 공유하게 된다.
- 객체 인스턴스에서 ```prototype```에 등록된 프로퍼티 값은 읽을 수 있지만 수정은 할 수 없다. 즉, 객체 인스턴스에서 ```prototype```에 동일한 이름으로 등록된 프로퍼티 값을 수정하면 ```prototype```의 프로퍼티는 가리고 객체 인스턴스에 새로운 프로퍼티로 등록된다.

```javascript
function Song() {}

Song.prototype.title = 'Sing';
Song.prototype.artist = 'Ed Sheeran';

Song.prototype.getDescription = function(release) {
  return this.title + ' released in ' + release;
};


var song1 = new Song(),
    song2 = new Song();

console.log(song1.getDescription(2014)); // 'Sing released in 2014'
console.log(song2.getDescription(2015)); // 'Sing released in 2015'

console.log(song1.getDescription === song2.getDescription); // true

```

#### 프로토타입 패턴 응용 1 : ```prototype```에 등록된 메서드에서 새로운 프로퍼티를 할당하고 값을 가져오면 어떻게 될까?
- ```prototype```에 등록된 메서드 내부의 ```this```는 생성된 객체 인스턴스를 가리킨다.
- 새로운 프로퍼티를 생성하면 ```prototype```의 멤버로 등록되는 것이 아니다.

```javascript
function Song() {}

Person.prototype.getTitle = function() {
  return this.title;
};

Person.prototype.setDescription = function(desc) {
  this.desc = desc;
};

var mySong = new Song();

console.log(mySong.getTitle()); // 'undefined'

mySong.name = 'Sing';

console.log(mySong.getName()); // 'Sing'

mySong.setDescription('so goooood');

console.log(mySong.desc); // 'so goooood'
console.log(mySong.prototype.desc); // error
```

#### 프로토타입 패턴 응용 2 : 멤버(프로퍼티, 메서드)를 객체 리터럴로 생성하기
- ```prototype```에 멤버 등록 시 객체 리터럴로 생성하면 반복적인 작업을 줄이고 가독성을 높일 수 있다.
- ```contstructor``` 프로퍼티가 생성된 객체를 가리키지 않는 단점이 있다. (객체 타입을 정확히 알 수 없다)
- ES5의```Object.defineProperty()``` 메서드로 ```consturctor``` 값을 해당 생성 객체로 강제할 수 있다.

```javascript
function Song() {}

Song.prototype = {
  title: 'Sing',
  desc: null,
  getTitle: function() {
    return this.title;
  },
  setDescription: function(desc) {
    this.desc = desc;
  }
};

var mySong = new Song();

console.log(mySong instanceof Song); // true
console.log(mySong instanceof Object); // true

console.log(mySong.constructor === Song); // false
console.log(mySong.constructor === Object); // true

```

#### 6.2.4 생성자 패턴 + 프로토타입 패턴

#### 6.2.5 동적 프로토타입 패턴

#### 6.2.6 기생 생성자 패턴

#### 6.2.7 방탄 생성자 패턴


### 6.3 상속
- 객체 지향 언어에서 상속의 방법은 **인터페이스 상속(interface inheritation)**과 **구현 상속(implementation inheritance)** 방법이 있다.
- 인터페이스 상속은 메서드의 시그니처(껍데기)만 상속하는 방법이다.
- 구현 상속은 실제 메서드 자체를 상속하는 방법이다.
- ECMAScript에서는 **구현 상속**만 지원하며, **[프로토타입 체인](https://github.com/codepink/codepink.github.com/blob/master/_posts/2016-03-05-prototype.md)**을 이용해 구현된다.

#### 6.3.1 프로토타입 체인
- 생성자 함수의 ```prototype``` 객체와 인스턴스 생성 시 내부의 포인터를 이용해 상속을 구현한다. (생성자 함수 ```Parent``` - 부모, ```Child```- 자식으로 표현)
- ```Child.prototype```을 ```Parent```의 인스턴스로 덮어쓰는 방식이다. 이 때 생성된 연결 고리를 **프로토타입 체인**이라고 한다.
- ```Parent```의 인스턴스가 ```Child.prototype```으로 할당되면, ```Child.prototype``` 내부에는 ```Parent.prototype```을 가리키는 포인터를 가진다. 이 포인터를 이용해 ```Parent```의 메서드에 접근할 수 있게 된다. 


```javascript
function Parent() {
  this.firstName = 'code';
  this.lastName = 'blue'
}

Parent.prototype.getName = function() {
  return this.firstName + this.lastName;
};

function Child() {
  this.lastName = 'pink';
}

Child.prototype = new Parent();

var parent = new Parent();
var child = new Child();

parent.getName(); // 'codeblue';
child.getName(); // 'codepink';
```

#### 프로토타입과 인스턴스의 관계 확인하기
- ```instnaceof``` 키워드 사용
- ```isPrototypeOf()``` 메서드 사용
- 다음의 관계를 통해 모든 참조 타입은 ```Object``` 객체로부터 상속받음을 확인할 수 있다.

```javascript
function Parent() {}

function Child() {}

Child.prototype = new Parent(); // inherit

var parent = new Parent();
var child = new Child();

console.log(child instanceof Object); // true
console.log(child instanceof Parent); // true
console.log(child instanceof Child); // true

console.log(Object.prototype.isPrototypeOf(child)); // true
console.log(Parent.prototype.isPrototypeOf(child)); // true
console.log(Child.prototype.isPrototypeOf(child)); // true
```

#### 프로토타입 체인 방식의 단점 1
- ```Child.prototype```의 메서드는 무조건 상속 관계 생성 이후에 선언되어야 한다.

```javascript
function Parent() {}

function Child() {}

Child.prototype.sayName = function() {
  console.log('codepink');
};

Child.prototype = new Parent(); // inherit

var child = new Child();

child.sayName(); // error
```

#### 프로토타입 체인 방식의 단점 2
- 객체 리터럴 방식으로 ```Child.prototype``` 메서드를 정의할 경우 상속의 관계가 끊어진다. (객체 리터럴 값이 ```Child.prototype```을 덮어쓴다)

```javascript
function Parent() {}

function Child() {}

Child.prototype = new Parent(); // inherit

Child.prototype = {
  sayName: function() {
    console.log('codepink');
  }
};

var child = new Child();

child.sayName(); // 'codepink'

console.log(child instanceof Object); // true
console.log(child instanceof Parent); // false
console.log(child instanceof Child); // true
```

#### 프로토타입 체인 방식의 단점 3
- 프로퍼티는 고유한 값을 유지하기 위해 생성자 함수 안에서 정의하는데, 프로토타입 체인이 생성되면 ```Parent```의 인스턴스 프로퍼티들이 ```Child.prototype```에 선언되어 전체 공유 상태가 된다.
- 원시 타입은 상관없으나 참조 타입일 경우 값이 변경되면 다른 인스턴스의 값들도 변경된다.
- 상속의 관계는 보통 프로로타입 체인 방식을 사용하지만 단독으로 사용하지 않는다.

```javascript
function Parent() {
  this.firstName = 'code';
  this.character = ['active', 'cold'];
}

function Child() {}

Child.prototype = new Parent();

var one = new Child();

one.firstName = 'node';
one.character.push('soft');

var two = new Child();

console.log(one.firstName); // 'node'
console.log(one.character); // ['active', 'cold', 'soft'];

console.log(two.firstName); // 'code'
console.log(two.character); // ['active', 'cold', 'soft'];
```

#### 6.3.2 생성자 훔치기
- 프로토타입 체인 방식의 단점을 보완하기 위한 방법
- **위장 객체(object masquerading)**, **전통적 상속(classical inheriance)** 이라고도 부른다.
- 


#### 6.3.3 조합 상속

#### 6.3.4 프로토타입 상속

#### 6.3.5 기생 상속

#### 6.3.6 기생 조합 상속

