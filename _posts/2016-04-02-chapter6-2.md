## 6장 객체 지향 프로그래밍 (2부)

### 6.2 객체 생성
- 보통 **Object 생성자 사용** 또는 **객체 리터럴** 방식으로 객체를 생성한다.

```javascript
var instance1 = new Object(); // Object 생성자 사용 방식

var instance2 = {}; // 객체 리터럴 방식
```
- 위의 방식으로 객체를 생성하면 같은 인터페이스를 가진 객체를 생성할 때 중복된 코드를 많이 써야하는 단점이 있다.
- 이를 해결하기 위해 다양한 **패턴(pattern)**의 객체 생성 방식이 등장

#### 6.2.1 팩터리 패턴
- 객체 생성 과정을 추상화 하는 방법이다.
- **추상화(abstract)**란 공통된 일을 하는 코드들을 묶어 함수로 만드는 것이다.
- **Object 생성자 사용** 방식을 이용해 객체를 생성하는 과정을 **팩터리 함수**로 만든다.
- 팩터리 함수에서 생성된 객체는 반환된다.
- 중복 코드에 대한 반복적인 작업은 줄어들지만, 생성한 객체의 타입을 알 수 없다. (모든 객체가 ```Object``` 객체로부터 생성되므로)

```javascript
function factoryOfSong(title, artist, release) {
  var o = new Object();
  
  o.title = title;
  o.artist = artist;
  
  o.getDescription = function() {
    return this.title + ' released in ' + release;
  };
  
  return o;
}

var song1 = factoryOfSong('Sing', 'Ed Sheeran', '2014'),
    song2 = factoryOfSong('Twenty-Something', 'Pet Shop Boys', '2016');
```

#### 6.2.2 생성자 패턴
- 팩터리 패턴을 확장한 방법이다.
- ```new``` 연산자를 사용해 팩터리 함수의 과정을 **생성자 함수**로 만들고, ```Object``` 객체에 할당된 멤버를 생성자 함수의 ```this``` 객체에 할당한다. (일반 함수 Vs. 생성자 함수 참조)
- 생성되는 인스턴스마다 메서드가 생성되는 단점이 있어, 메서드를 생성자 함수 밖에서 선언할 수도 있지만 이는 **전역 스코프**를 어지럽힌다.

```javascript
function Song(title, artist, release) {
  this.title = title;
  this.artist = artist;
  
  /*
  
  // this line is same below method
  this.getDescription = new Function(..);
  
  */
  this.getDescription = function() {
    return this.title + ' released in ' + release;
  };
}

var song1 = new Song('Sing', 'Ed Sheeran', '2014'),
    song2 = new Song('Twenty-Something', 'Pet Shop Boys', '2016');
```

#### 일반 함수 Vs. 생성자 함수
- 함수명 표기 방법 (규칙으로 한다)
  - 일반 함수 : 소문자 시작
  - 생성자 함수 : 대문자로 시작
- 호출 방법
  - 일반 함수 : 함수명 호출 
  - 생성자 함수 : ```new``` 연산자와 함께 사용되며 호출시 객체가 생성된다.
- 함수 내부에서 ```this``` 객체 차이
  - 일반 함수 : ```call()```, ```apply()``` 함수를 이용해 명시적으로 호출하지 않으면 ```window``` 객체에 묶인다.
  - 생성자 함수 : 현재 생성되는 객체에 묶인다.

```javascript
function Person(name, age) { // 표기법은 생성자 함수를 따르나 호출 방법에 따라 구분된다.
  this.name = name;
  this.age = age;
  
  this.printInfo = function() {
    console.log(this.name + ', ' + this.age);
  }
}

var developer = new Person('codepink', 31); // 생성자 함수로 호출

developer.getInfo(); // 'codepink, 31'

Person('codeblue', 30); // 일반 함수로 호출

window.getInfo(); // 'codeblue, 30'
```

#### 6.2.3 프로토타입 패턴
- 모든 함수는 ```prototype``` 프로퍼티를 가진다.
- ```prototype```에 멤버(프로퍼티, 메서드)를 등록하고 생성자 함수로 객체를 생성하게 되면, 생성된 객체들에게 등록된 멤버를 공유하게 된다.
- 객체 인스턴스에서 ```prototype```에 등록된 프로퍼티 값은 읽을 수 있지만 수정은 할 수 없다. 즉, 객체 인스턴스에서 ```prototype```에 동일한 이름으로 등록된 프로퍼티 값을 수정하면 ```prototype```의 프로퍼티는 가리고 객체 인스턴스에 새로운 프로퍼티로 등록된다.

```javascript
function Song() {}

Song.prototype.title = 'Sing';
Song.prototype.artist = 'Ed Sheeran';

Song.prototype.getDescription = function(release) {
  return this.title + ' released in ' + release;
};


var song1 = new Song(),
    song2 = new Song();

console.log(song1.getDescription(2014)); // 'Sing released in 2014'
console.log(song2.getDescription(2015)); // 'Sing released in 2015'

console.log(song1.getDescription === song2.getDescription); // true

```

#### 프로토타입 패턴 응용 1 : ```prototype```에 등록된 메서드에서 새로운 프로퍼티를 할당하고 값을 가져오면 어떻게 될까?
- ```prototype```에 등록된 메서드 내부의 ```this```는 생성된 객체 인스턴스를 가리킨다.
- 새로운 프로퍼티를 생성하면 ```prototype```의 멤버로 등록되는 것이 아니다.

```javascript
function Song() {}

Person.prototype.getTitle = function() {
  return this.title;
};

Person.prototype.setDescription = function(desc) {
  this.desc = desc;
};

var mySong = new Song();

console.log(mySong.getTitle()); // 'undefined'

mySong.name = 'Sing';

console.log(mySong.getName()); // 'Sing'

mySong.setDescription('so goooood');

console.log(mySong.desc); // 'so goooood'
console.log(mySong.prototype.desc); // error
```

#### 프로토타입 패턴 응용 2 : 멤버(프로퍼티, 메서드)를 객체 리터럴로 생성하기
- ```prototype```에 멤버 등록 시 객체 리터럴로 생성하면 반복적인 작업을 줄이고 가독성을 높일 수 있다.
- ```contstructor``` 프로퍼티가 생성된 객체를 가리키지 않는 단점이 있다. (객체 타입을 정확히 알 수 없다)
- ES5의```Object.defineProperty()``` 메서드로 ```consturctor``` 값을 해당 생성 객체로 강제할 수 있다.

```javascript
function Song() {}

Song.prototype = {
  title: 'Sing',
  desc: null,
  getTitle: function() {
    return this.title;
  },
  setDescription: function(desc) {
    this.desc = desc;
  }
};

var mySong = new Song();

console.log(mySong instanceof Song); // true
console.log(mySong instanceof Object); // true

console.log(mySong.constructor === Song); // false
console.log(mySong.constructor === Object); // true

```

#### 6.2.4 생성자 패턴 + 프로토타입 패턴
- 커스텀 타입의 객체를 정의할 때 가장 많이 사용되는 방법이다.
- 프로퍼티는 **생성자 패턴**, 메서드는 **프로토타입 패턴**으로 정의한다.

```javascript
function Album(info) {
  this.title = info.title;
  this.artist = info.artist;
  this.songs = info.songs; // 참조타입
}

Album.prototype.getInfo = function() {
  return this.title + ' / ' + this.artist;
};

Album.prototype.getSongs = function() {
  return this.songs.join(' / ');
};

var myAlbum = new Album({
  title: 'X',
  artist: 'Ad Sheeran',
  songs: ['One', 'Sing', 'Nina']
});

var yourAlbum = new Album({
  title: '+',
  artist: 'Ad Sheeran',
  songs: ['This', 'The City']
});

console.log(myAlbum.getInfo()); // 'X / Ad Sheeran'
console.log(myAlbum.getSongs()); // 'One / Sing / Nina'

console.log(yourAlbum.getInfo()); // '+ / Ad Sheeran'
console.log(yourAlbum.getSongs()); // 'This / The City'

console.log(myAlbum.songs === yourAlbum.songs); // false
console.log(myAlbum.getInfo === yourAlbum.getInfo); // true
```

#### 6.2.5 동적 프로토타입 패턴
- 생성자 함수 내부에서 ```prototype```에 메서드를 모두 정의하는 방식이다. (마치 다른 언어의 ```class```처럼)
- 생성자 내부에서 메서드를 정의할 경우 객체가 생성될 때마다 메서드를 생성할 수 있으므로 예외처리가 필요하다.
- 리터럴 방식으로 ```prototype``` 메서드가 정의된 경우에는 사용할 수 없다.

```javascript
function Album(info) {
  this.title = info.title;
  this.artist = info.artist;
  this.songs = info.songs;
  
  if (typeof this.getInfo !== 'function') { // 메서드는 최초에 생성되므로 if 조건 체크도 1회만 함
    Album.prototype.getInfo = function() {
      return this.title + ' / ' + this.artist;
    };
  
    Album.prototype.getSongs = function() {
      return this.songs.join(' / ');
    };
  }
}

var myAlbum = new Album({
  title: 'X',
  artist: 'Ad Sheeran',
  songs: ['One', 'Sing', 'Nina']
});

console.log(myAlbum.getInfo()); // 'X / Ad Sheeran'
console.log(myAlbum.getSongs()); // 'One / Sing / Nina'
```

#### 6.2.6 기생 생성자 패턴
- 다른 패턴이 실패할 때 **폴백(fullback)**으로 사용한다.
- **팩터리 패턴 + 생성자 패턴**의 조합으로, 팩터리 패턴의 구현체를 생성자 함수로 감싸는 방식이다.
- 참조 타입을 확장하거나 할 때 사용한다. (좋은 방법은 아니다..)

```javascript
function Song(title, artist) {
  var o = new Object();
  
  o.title = title;
  o.artist = artist;
  
  o.getInfo = function() {
    return this.title + ' / ' + this.artist;
  };
  
  return o;
}

var mySong = new Song('Sing', 'Ad Sheeran');

mySong.getInfo(); // 'Sing / Ad Sheeran'
```

#### 기생 생성자 패턴으로 ```String``` 객체 확장해 보기

```javascript
function MyString(original, find, replace) {
  var myString = new String(original);
  
  myString.spectialText = replace;

  myString.replaceSpecialText = function() {
    return this.replace(find, this.spectialText);
  };
  
  return myString;
}

var myIntroduce = new MyString('Hi, my name is *!', '*', 'codepink');

myIntroduce.replaceSpecialText(); // 'Hi, my name is codepink!'

var yourIntroduce = new MyString('Hi, my name is &!', '&', 'codeblue');

yourIntroduce.replaceSpecialText(); // 'Hi, my name is codeblue!'

```

#### 6.2.7 방탄 생성자 패턴
- **방탄(durable)**이란 용어는 공유 프로퍼티가 없고 메서드가 ```this```를 참조하지 않는 객체를 뜻한다.
- ```this```, ```new``` 등의 키워드를 금지하는 **보안 환경***, **매시업 어플리케이션**에서 사용할 수 있다.
- **기생 생성자 패턴**을 사용하되 생성자 함수 내부에서 ```this```를 사용하지 않고, 객체 생성시에 ```new```를 사용하지 않고 함수 호출만 한다.

```javascript
function Song(title, artist) {
  var o = new Object();
  
  //o.title = title;
  //o.artist = artist;
  
  o.getInfo = function() { // 클로저 함수
    return title + ' / ' + artist;
  };
  
  return o;
}

var mySong = Song('Sing', 'Ad Sheeran');

mySong.getInfo(); // 'Sing / Ad Sheeran'
```

### 6.3 상속
- 객체 지향 언어에서 상속의 방법은 **인터페이스 상속(interface inheritation)**과 **구현 상속(implementation inheritance)** 방법이 있다.
- 인터페이스 상속은 메서드의 시그니처(껍데기)만 상속하는 방법이다.
- 구현 상속은 실제 메서드 자체를 상속하는 방법이다.
- ECMAScript에서는 **구현 상속**만 지원하며, **[프로토타입 체인](https://github.com/codepink/codepink.github.com/blob/master/_posts/2016-03-05-prototype.md)**을 이용해 구현된다.

#### 6.3.1 프로토타입 체인
- 생성자 함수의 ```prototype``` 객체와 인스턴스 생성 시 내부의 포인터를 이용해 상속을 구현한다. (이후 예제에서는 부모 - ```Parent```, 자식 - ```Child``로 생성자 함수를 정의한다)
- ```Child.prototype```을 ```Parent```의 인스턴스로 덮어쓰는 방식이다. 이 때 생성된 연결 고리를 **프로토타입 체인**이라고 한다.
- ```Parent```의 인스턴스가 ```Child.prototype```으로 할당되면, ```Child.prototype``` 내부에는 ```Parent.prototype```을 가리키는 포인터를 가진다. 이 포인터를 이용해 ```Parent```의 메서드에 접근할 수 있게 된다. 


```javascript
function Parent() {
  this.firstName = 'code';
  this.lastName = 'blue'
}

Parent.prototype.getName = function() {
  return this.firstName + this.lastName;
};

function Child() {
  this.lastName = 'pink';
}

Child.prototype = new Parent();

var parent = new Parent();
var child = new Child();

parent.getName(); // 'codeblue';
child.getName(); // 'codepink';
```

#### 프로토타입과 인스턴스의 관계 확인하기
- ```instnaceof``` 키워드 사용
- ```isPrototypeOf()``` 메서드 사용
- 다음의 관계를 통해 모든 참조 타입은 ```Object``` 객체로부터 상속받음을 확인할 수 있다.

```javascript
function Parent() {}

function Child() {}

Child.prototype = new Parent(); // inherit

var parent = new Parent();
var child = new Child();

console.log(child instanceof Object); // true
console.log(child instanceof Parent); // true
console.log(child instanceof Child); // true

console.log(Object.prototype.isPrototypeOf(child)); // true
console.log(Parent.prototype.isPrototypeOf(child)); // true
console.log(Child.prototype.isPrototypeOf(child)); // true
```

#### 프로토타입 체인 방식의 단점 1
- ```Child.prototype```의 메서드는 무조건 상속 관계 생성 이후에 선언되어야 한다.

```javascript
function Parent() {}

function Child() {}

Child.prototype.sayName = function() {
  console.log('codepink');
};

Child.prototype = new Parent(); // inherit

var child = new Child();

child.sayName(); // error
```

#### 프로토타입 체인 방식의 단점 2
- 객체 리터럴 방식으로 ```Child.prototype``` 메서드를 정의할 경우 상속의 관계가 끊어진다. (객체 리터럴 값이 ```Child.prototype```을 덮어쓴다)

```javascript
function Parent() {}

function Child() {}

Child.prototype = new Parent(); // inherit

Child.prototype = {
  sayName: function() {
    console.log('codepink');
  }
};

var child = new Child();

child.sayName(); // 'codepink'

console.log(child instanceof Object); // true
console.log(child instanceof Parent); // false
console.log(child instanceof Child); // true
```

#### 프로토타입 체인 방식의 단점 3
- 프로퍼티는 고유한 값을 유지하기 위해 생성자 함수 안에서 정의하는데, 프로토타입 체인이 생성되면 ```Parent```의 인스턴스 프로퍼티들이 ```Child.prototype```에 선언되어 전체 공유 상태가 된다.
- 원시 타입은 상관없으나 참조 타입일 경우 값이 변경되면 다른 인스턴스의 값들도 변경된다.
- 상속의 관계는 보통 프로로타입 체인 방식을 사용하지만 단독으로 사용하지 않는다.

```javascript
function Parent() {
  this.firstName = 'code';
  this.character = ['active', 'cold'];
}

function Child() {}

Child.prototype = new Parent();

var one = new Child();

one.firstName = 'node';
one.character.push('soft');

var two = new Child();

console.log(one.firstName); // 'node'
console.log(one.character); // ['active', 'cold', 'soft'];

console.log(two.firstName); // 'code'
console.log(two.character); // ['active', 'cold', 'soft'];
```

#### 6.3.2 생성자 훔치기
- 프로토타입 체인 방식의 단점을 보완하기 위한 방법
- **위장 객체(object masquerading)**, **전통적 상속(classical inheriance)** 이라고도 부른다.
- 상속을 받는 생성자 함수 안에서 상위 타입의 생성자 함수를 호출하는 방식이다.
- ```apply()```, ```call()``` 메서드를 이용한다.

```javascript
function Parent() {
  this.firstName = 'code';
  this.character = ['active', 'cold'];
}

function Child() {
  Parent.call(this); // context가 Child가 되어 호출되므로 이하 this 값을 상속받는 형태가 된다.
}

var one = new Child();

one.firstName = 'node';
one.character.push('soft');

var two = new Child();

console.log(one.firstName); // 'node'
console.log(one.character); // ['active', 'cold', 'soft'];

console.log(two.firstName); // 'code'
console.log(two.character); // ['active', 'cold'];
```

#### 생성자 훔치기 패턴의 응용 (매개변수 전달하기)

```javascript
function Parent(name, age) {
  this.name = name;
  this.age = age;
}

Parent.prototype.getName = function() {
  return this.name;
};

function Child(name, age, job) {
  Parent.apply(this, [name, age]);
  
  this.job = job;
}

Child.prototype.printProfile = function() {
  console.log(this.name);
  console.log(this.age);
  console.log(this.job);
};

var child = new Child('codepink', 31, 'developer');

child.printProfile(); // 'codepink', 31, 'developer'
child.getName(); // error
```

#### 생성자 훔치기 패턴의 단점
- 프로토타입 체인 방식의 단점 1, 2와 같은 문제가 발생한다.
- ```Parent.prototype```에 정의된 메서드를 ```Child```가 접근할 수 없다.

#### 6.3.3 조합 상속
- **프로토타입 체인 + 생성자 훔치기 패턴**의 조합이다.
- 프로퍼티 상속은 **생성자 훔치기 패턴**, 메서드 상속은 **프로토타입 체인**을 사용한다.
- 부모 생성자가 2번 호출되는 단점이 있다. (```new Parent()```, ```Parent.apply()```)

```javascript
function Parent(name, age) {
  this.name = name;
  this.age = age;
}

Parent.prototype.getName = function() {
  return this.name;
};

function Child(name, age, job) {
  Parent.apply(this, [name, age]);
  
  this.job = job;
}

Child.prototype = new Parent(); // inherit() 함수로 정의해 사용할 수도 있다.

Child.prototype.printProfile = function() {
  console.log(this.name);
  console.log(this.age);
  console.log(this.job);
};

var child = new Child('codepink', 31, 'developer');

child.printProfile(); // 'codepink', 31, 'developer'
child.getName(); // 'codepink'
```

#### 6.3.4 프로토타입 상속
- **더글라스 크록포드**가 고안한 방식이다.
- 특정 생성자 함수(```Parent```, ```Child```에 해당)를 사용하지 않고도 상속을 구현할 수 있는 방식이다. (생성자를 매번 만드는 것은 생각보다 귀찮다..)
- 임시 생성자 함수를 정의하고 ```prototype```에 객체를 할당한 다음 임시 생성자 함수를 반환해 사용한다.
- ES5에서는 ````Object.create()``` 메서드로 프로토타입 상속을 구현했다.

```javascript
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}

var parent = {
  firstName: 'code',
  getName: function(name) {
    return this.firstName + name;
  }
};

var one = object(parent);
var two = object(parent);

console.log(one.getName('pink')); // 'codepink'
console.log(two.getName('blue')); // 'codeblue'
```

#### ES5 메서드로 상속 확장하기

```javascript
var parent = {
  firstName: 'code',
  lastName: 'pink',
  getName: function() {
    return this.firstName + this.lastName;
  }
};

var one = Object.create(parent); // 일반 상속
var two = Object.create(parent, { // 상속 확장
  lastName: {
    value: 'blue'
  }
});

console.log(one.getName()); // 'codepink'
console.log(two.getName()); // 'codeblue'
```

#### 6.3.5 기생 상속
- **기생 생성자 패턴**, **팩터리 패턴**을 이용한다.
- **프로토타입 상속** 함수를 다른 함수로 한 번 더 감싸서 확장하는 방식이다.
- 메서드를 추가하여 확장할 경우 특정 객체를 고려해야 하며, **생성자 패턴** 방식과 유사한 단점이 발생한다.

```javascript
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}

function factory(original) {
  var clone = object(original);
  
  clone.setTitle = function(title) {
    this.title = title;
  };
  
  clone.getTitle = function() {
    return this.title;
  };
  
  return clone;
}

var song = {
  title: 'sing'
};

var cloneSong = factory(song);

cloneSong.setTitle('sang');
cloneSong.getTitle(); // 'sang'
```

#### 6.3.6 기생 조합 상속
- **기생 상속 + 조합 상속**의 조합 패턴이며, **조합 상속**의 단점을 해결하는 방식이다.
- 기본적인 조합 상속의 방식을 따르되 상위 타입의 생성자를 호출할 필요가 없다. (부모 생성자가 2번 호출되지 않는다)

#### inheritPrototype() 구현 방식 1

```javascript
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}

function inheritPrototype(Child, Parent) {
  var prototype = object(Parent.prototype); // 객체 생성
  prototype.constuctor = Child; // 객체 확장
  Child.prototype = prototype; // 객체 할당
}
```

#### inheritPrototype() 구현 방식 2

```javascript
function inheritPrototype(Child, Parent) {
  function F() {}
  F.prototype = Parent.prototype; 
  Child.prototype = new F();
  Child.prototype.constuctor = Child;
}
```

#### inheritPrototype() 메서드로 상속하기

```javascript
function inheritPrototype(Child, Parent) {
  function F() {}
  F.prototype = Parent.prototype; 
  Child.prototype = new F();
  Child.prototype.constuctor = Child;
}

function Parent() {
  this.firstName = 'code';
}

Parent.prototype.getName = function() {
  return this.firstName + this.lastName;
};

function Child(name) {
  Parent.call(this); // 부모 생성자는 1번만 호출
  
  this.lastName = name;
}

inheritPrototype(Child, Parent);

var parent = new Parent('code');
var child = new Child('pink');

child.getName(); // 'codepink'
```
