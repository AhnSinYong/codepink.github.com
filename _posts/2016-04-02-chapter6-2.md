## 6장 객체 지향 프로그래밍 (2부)

### 6.2 객체 생성
- 보통 **Object 생성자 사용** 또는 **객체 리터럴** 방식으로 객체를 생성한다.

```javascript
var instance1 = new Object(); // Object 생성자 사용 방식

var instance2 = {}; // 객체 리터럴 방식
```
- 위의 방식으로 객체를 생성하면 같은 인터페이스를 가진 객체를 생성할 때 중복된 코드를 많이 써야하는 단점이 있다.
- 이를 해결하기 위해 다양한 **패턴(pattern)**의 객체 생성 방식이 등장

#### 6.2.1 팩터리 패턴
- 객체 생성 과정을 추상화 하는 방법이다.
- **추상화(abstract)**란 공통된 일을 하는 코드들을 묶어 함수로 만드는 것이다.
- **Object 생성자 사용** 방식을 이용해 객체를 생성하는 과정을 **팩터리 함수**로 만든다.
- 팩터리 함수에서 생성된 객체는 반환된다.
- 중복 코드에 대한 반복적인 작업은 줄어들지만, 생성한 객체의 타입을 알 수 없다. (모든 객체가 ```Object``` 객체로부터 생성되므로)

```javascript
function factoryOfSong(title, artist, release) {
  var o = new Object();
  
  o.title = title;
  o.artist = artist;
  
  o.getDescription = function() {
    return this.title + ' released in ' + release;
  };
  
  return o;
}

var song1 = factoryOfSong('Sing', 'Ed Sheeran', '2014'),
    song2 = factoryOfSong('Twenty-Something', 'Pet Shop Boys', '2016');
```

#### 6.2.2 생성자 패턴
- 팩터리 패턴을 확장한 방법이다.
- ```new``` 연산자를 사용해 팩터리 함수의 과정을 **생성자 함수**로 만들고, ```Object``` 객체에 할당된 멤버를 생성자 함수의 ```this``` 객체에 할당한다. (일반 함수 Vs. 생성자 함수 참조)
- 생성되는 인스턴스마다 메서드가 생성되는 단점이 있어, 메서드를 생성자 함수 밖에서 선언할 수도 있지만 이는 **전역 스코프**를 어지럽힌다.

```javascript
function Song(title, artist, release) {
  this.title = title;
  this.artist = artist;
  
  /*
  
  // this line is same below method
  this.getDescription = new Function(..);
  
  */
  this.getDescription = function() {
    return this.title + ' released in ' + release;
  };
}

var song1 = new Song('Sing', 'Ed Sheeran', '2014'),
    song2 = new Song('Twenty-Something', 'Pet Shop Boys', '2016');
```

#### 일반 함수 Vs. 생성자 함수
- 함수명 표기 방법 (규칙으로 한다)
  - 일반 함수 : 소문자 시작
  - 생성자 함수 : 대문자로 시작
- 호출 방법
  - 일반 함수 : 함수명 호출 
  - 생성자 함수 : ```new``` 연산자와 함께 사용되며 호출시 객체가 생성된다.
- 함수 내부에서 ```this``` 객체 차이
  - 일반 함수 : ```call()```, ```apply()``` 함수를 이용해 명시적으로 호출하지 않으면 ```window``` 객체에 묶인다.
  - 생성자 함수 : 현재 생성되는 객체에 묶인다.

```javascript
function Person(name, age) { // 표기법은 생성자 함수를 따르나 호출 방법에 따라 구분된다.
  this.name = name;
  this.age = age;
  
  this.printInfo = function() {
    console.log(this.name + ', ' + this.age);
  }
}

var developer = new Person('codepink', 31); // 생성자 함수로 호출

developer.getInfo(); // 'codepink, 31'

Person('codeblue', 30); // 일반 함수로 호출

window.getInfo(); // 'codeblue, 30'
```

#### 6.2.3 프로토타입 패턴
- 모든 함수는 ```prototype``` 프로퍼티를 가진다.
- ```prototype```에 멤버(프로퍼티, 메서드)를 등록하고 생성자 함수로 객체를 생성하게 되면, 생성된 객체들에게 등록된 멤버를 공유하게 된다.
- 객체 인스턴스에서 ```prototype```에 등록된 프로퍼티 값은 읽을 수 있지만 수정은 할 수 없다. 즉, 객체 인스턴스에서 ```prototype```에 동일한 이름으로 등록된 프로퍼티 값을 수정하면 ```prototype```의 프로퍼티는 가리고 객체 인스턴스에 새로운 프로퍼티로 등록된다.

```javascript
function Song() {}

Song.prototype.title = 'Sing';
Song.prototype.artist = 'Ed Sheeran';

Song.prototype.getDescription = function(release) {
  return this.title + ' released in ' + release;
};


var song1 = new Song(),
    song2 = new Song();

console.log(song1.getDescription(2014)); // 'Sing released in 2014'
console.log(song2.getDescription(2015)); // 'Sing released in 2015'

console.log(song1.getDescription === song2.getDescription); // true

```

#### 프로토타입 패턴 응용 1 : ```prototype```에 등록된 메서드에서 새로운 프로퍼티를 할당하고 값을 가져오면 어떻게 될까?
- ```prototype```에 등록된 메서드 내부의 ```this```는 생성된 객체 인스턴스를 가리킨다.
- 새로운 프로퍼티를 생성하면 ```prototype```의 멤버로 등록되는 것이 아니다.

```javascript
function Song() {}

Person.prototype.getTitle = function() {
  return this.title;
};

Person.prototype.setDescription = function(desc) {
  this.desc = desc;
};

var mySong = new Song();

console.log(mySong.getTitle()); // 'undefined'

mySong.name = 'Sing';

console.log(mySong.getName()); // 'Sing'

mySong.setDescription('so goooood');

console.log(mySong.desc); // 'so goooood'
console.log(mySong.prototype.desc); // error
```

#### 프로토타입 패턴 응용 2 : 멤버(프로퍼티, 메서드)를 객체 리터럴로 생성하기
- ```prototype```에 멤버 등록 시 객체 리터럴로 생성하면 반복적인 작업을 줄이고 가독성을 높일 수 있다.
- ```contstructor``` 프로퍼티가 생성된 객체를 가리키지 않는 단점이 있다. (객체 타입을 정확히 알 수 없다)
- ES5의```Object.defineProperty()``` 메서드로 ```consturctor``` 값을 해당 생성 객체로 강제할 수 있다.

```javascript
function Song() {}

Song.prototype = {
  title: 'Sing',
  desc: null,
  getTitle: function() {
    return this.title;
  },
  setDescription: function(desc) {
    this.desc = desc;
  }
};

var mySong = new Song();

console.log(mySong instanceof Song); // true
console.log(mySong instanceof Object); // true

console.log(mySong.constructor === Song); // false
console.log(mySong.constructor === Object); // true

```

#### 6.2.4 생성자 패턴 + 프로토타입 패턴

#### 6.2.5 동적 프로토타입 패턴

#### 6.2.6 기생 생성자 패턴

#### 6.2.7 방탄 생성자 패턴


### 6.3 상속
- 객체 지향 언어에서 상속의 방법은 **인터페이스 상속(interface inheritation)**과 **구현 상속(implementation inheritance)** 방법이 있다.
- 인터페이스 상속은 메서드의 시그니처(껍데기)만 상속하는 방법이다.
- 구현 상속은 실제 메서드 자체를 상속하는 방법이다.
- ECMAScript에서는 **구현 상속**만 지원하며, **[프로토타입 체인](https://github.com/codepink/codepink.github.com/blob/master/_posts/2016-03-05-prototype.md)**을 이용해 구현된다.

#### 6.3.1 프로토타입 체인

#### 6.3.2 생성자 훔치기

#### 6.3.3 조합 상속

#### 6.3.4 프로토타입 상속

#### 6.3.5 기생 상속

#### 6.3.6 기생 조합 상속

